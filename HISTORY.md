# KODEX 코스닥150 레버리지 자동매매봇 - 변천사

> 이 문서는 트레이딩봇이 어떻게 진화해왔는지를 기록합니다.
> 주식/경제 용어를 모두 설명하고, 코드의 모든 기능을 설명합니다.

---

## 용어 사전 (이것부터 읽어주세요!)

### 주식 기본 용어

| 용어 | 뜻 |
|------|------|
| **주식** | 회사의 일부를 사는 것. 회사가 잘 되면 주식 가격이 올라서 돈을 벌 수 있음 |
| **ETF** | 여러 주식을 한 바구니에 담은 상품. 하나만 사면 여러 회사에 투자한 효과 |
| **KODEX 코스닥150 레버리지** | 코스닥(작은 회사들의 주식시장) 상위 150개 회사에 투자하되, 오르내림이 **2배**로 증폭되는 ETF. 코스닥이 1% 오르면 이 ETF는 ~2% 오름 |
| **시가** | 그 날 장이 열렸을 때 맨 처음 거래된 가격 |
| **종가** | 그 날 장이 닫힐 때 마지막으로 거래된 가격 |
| **고가** | 그 날 중 가장 높았던 가격 |
| **저가** | 그 날 중 가장 낮았던 가격 |
| **거래량** | 하루 동안 사고팔린 주식의 총 개수 |
| **매수** | 주식을 사는 것 |
| **매도** | 주식을 파는 것 |
| **수수료** | 주식을 사고팔 때 증권사에 내는 비용 (우리 모의투자는 왕복 0.93%) |
| **익절** | 이익을 보고 파는 것 (예: +5%에서 팔기) |
| **손절** | 손해를 보고 파는 것 (예: -3%에서 팔기, 더 떨어지기 전에 빠져나오기) |
| **시장가 주문** | "지금 당장 아무 가격이나 좋으니 사/팔겠다!"는 주문. 가장 빠르게 체결됨 |
| **모의투자** | 진짜 돈이 아닌 가짜 돈으로 연습하는 것 |
| **불장(Bull Market)** | 주가가 계속 오르는 시장. 황소가 뿔로 위로 찌르는 모습에서 유래 |
| **하락장(Bear Market)** | 주가가 계속 떨어지는 시장. 곰이 발톱으로 아래로 내리치는 모습에서 유래 |

### 기술적 지표 용어

| 용어 | 뜻 | 비유 |
|------|------|------|
| **MA (이동평균선)** | 최근 N일간 가격의 평균. MA5는 5일 평균, MA20은 20일 평균 | 시험 성적의 평균. 5번의 평균이 20번의 평균보다 높으면 "요즘 성적이 올라가는 중" |
| **골든크로스** | MA5(단기 평균)가 MA20(장기 평균)을 아래에서 위로 뚫고 올라가는 순간. "상승 시작!" 신호 | 최근 성적이 장기 평균을 넘기 시작한 순간 |
| **데드크로스** | MA5가 MA20을 위에서 아래로 뚫고 내려가는 순간. "하락 시작!" 신호 | 최근 성적이 장기 평균 아래로 떨어진 순간 |
| **RSI (상대강도지수)** | 0~100 사이 숫자. 70 이상이면 "너무 많이 올라서 곧 떨어질 수 있음", 30 이하면 "너무 떨어져서 곧 반등할 수 있음" | 체력 게이지. 100에 가까우면 지쳐서 곧 쉴 때, 0에 가까우면 충전 완료 |
| **볼린저 밴드** | 가격이 움직이는 평소 범위를 보여주는 위아래 띠. 윗띠를 뚫으면 비정상적으로 올라간 것, 아랫띠를 뚫으면 비정상적으로 내려간 것 | 학교 성적으로 치면 "상위 5%"와 "하위 5%" 경계선 |
| **MACD** | 두 이동평균선의 차이를 계산한 것. 주가의 방향과 힘을 알려줌 | 자동차 속도계. 양수면 가속 중, 음수면 감속 중 |
| **트렌드(추세)** | 가격이 일정 방향으로 계속 움직이는 흐름. 상승 트렌드, 하락 트렌드 | 에스컬레이터. 올라가는 에스컬레이터를 타면 가만히 있어도 올라감 |

### 전략 용어

| 용어 | 뜻 |
|------|------|
| **백테스팅** | 과거 데이터에 전략을 적용해서 "이 전략을 썼으면 돈을 벌었을까?" 확인하는 것 |
| **Buy & Hold** | 그냥 사서 쭉 들고 있는 것. 아무것도 안 하는 전략 |
| **변동성 돌파** | 전날 가격이 출렁인 폭(고가-저가)을 기준으로, 오늘 일정 수준 이상 올라가면 "돌파했다!"고 판단하고 사는 전략 |
| **트레일링 스탑** | 주가가 올라갈 때는 팔지 않다가, 최고점에서 일정% 떨어지면 파는 방식. "가능한 한 오래 타되, 떨어지기 시작하면 빠져나오자" |
| **데이터 누수(Data Leakage)** | 백테스팅할 때 미래의 정보가 섞여들어가서 결과가 실제보다 좋게 나오는 오류. 시험 문제를 미리 보고 푸는 것과 같음 |
| **Out-of-sample** | 모델이 한 번도 보지 못한 새로운 데이터. 진짜 실력을 측정하는 데 사용 |
| **5분봉** | 5분 간격으로 기록한 가격 차트. 하루에 약 78개의 봉이 생김 |
| **일봉** | 1일 간격으로 기록한 가격 차트. 하루에 딱 1개의 봉 |

---

## 프로젝트 파일 구조

```
tradingbot/
├── main.py          ← 실제로 돈을 사고파는 봇 (핵심!)
├── broker.py        ← 증권사와 대화하는 역할 (API 통신)
├── backtester.py    ← 과거 데이터로 전략을 시험해보는 도구
├── data_manager.py  ← 주가 데이터를 받아오는 역할 (현재 main.py에서 안 씀)
├── model.py         ← AI 모델 학습/저장 역할 (현재 main.py에서 안 씀)
├── .env             ← API 열쇠(비밀번호) 저장소
└── HISTORY.md       ← 이 파일!
```

---

## 1단계: 최초 버전 (하이브리드 v1.0)

### 전략 아이디어
"래리 윌리엄스 변동성 돌파 전략"과 "AI(XGBoost) 예측"을 합친 하이브리드 전략.

**쉽게 말하면:**
> "오늘 가격이 일정 수준을 넘어서면(변동성 돌파), 그리고 AI가 '올라갈 것 같아!'라고 75% 이상 확신하면 산다."

### 매수 조건
1. 현재 가격이 **목표가** 이상 (래리 윌리엄스 공식으로 계산)
2. AI가 **75% 이상** 확률로 "올라간다"고 예측

### 매도 조건
- 수익률 **+1.2%** 이상 → 익절 (이익 확정)
- 수익률 **-1.0%** 이하 → 손절 (손해 제한)
- AI 확신도 **40% 미만** → 확신도 급락 매도

### 설정값
```
K값 = 0.5 (변동성 돌파 기준)
매수 확신도 = 75%
익절 = +1.2%
손절 = -1.0%
데이터 = 60일치 5분봉 (1분마다 60일치 전체를 새로 다운로드)
매수 수량 = 1주 (고정)
```

### 백테스팅 결과
```
초기 자본: 10,000,000원
최종 자본: 10,244,237원
수익률: +2.44% (60일)
```

### 문제점들 (Claude가 발견한 것)

**문제 1: 1주만 산다**
> 1000만원이 있어도 17,000원짜리 주식을 딱 1주만 사니까, 돈의 99%가 놀고 있었음.
> 1.2% 익절해도 실제 수익은 204원 (수수료 158원 떼면 46원 남음)

**문제 2: 매분 60일치 데이터 전체를 새로 받음**
> 1분마다 인터넷에서 60일치 데이터(17,000개 행)를 다시 받음.
> 고속도로에서 100m 갈 때마다 차 세우고 지도를 새로 사는 것과 같았음.

**문제 3: 목표가가 비현실적 (현재가 17,000원 vs 목표가 18,525원)**
> K=0.5가 너무 높아서 목표가가 현재 가격보다 8.9% 위에 있었음.
> 레버리지 ETF라도 하루에 8.9% 오르려면 코스닥이 ~4.5% 올라야 함.
> 결론: 매수 신호가 거의 발생하지 않음!

**문제 4: AI가 예측하는 것과 실제 매매 기준이 달랐음**
> AI는 "10분 뒤 가격이 올라?"를 예측하는데, 실제 매도는 "1.2% 수익"이 기준.
> 완전히 다른 질문에 대한 답을 가지고 매매 판단을 한 셈.

**문제 5: 확신도가 극단적으로 흔들림**
> 1분 간격으로 8% → 56% → 64% → 10% 이렇게 널뛰기.
> 5분봉이 아직 완성되지 않은 상태에서 매번 지표를 새로 계산하니까 불안정했음.

**문제 6: 데이터 누수 (Data Leakage)**
> AI를 학습시킨 데이터와 백테스트하는 데이터가 같았음.
> 시험 문제를 미리 알고 시험을 본 것과 같아서 백테스트 결과를 믿을 수 없었음.

---

## 2단계: 개선 버전 (하이브리드 v2.0)

### 무엇을 고쳤나

**고친 것 1: 잔고 기반 수량 계산**
```python
# 이전: 항상 1주
broker.post_order(..., 1)

# 이후: 현금의 95%를 투자
cash = broker.get_balance(...)
buy_qty = int((cash * 0.95) / current_price)
```
> 100만원 잔고면 약 55주 매수 가능 (17,000원 기준)

**고친 것 2: 데이터 캐싱**
```python
# 이전: 매 1분마다 60일치 전체 재다운로드
df_raw = data_manager.fetch_large_data(TICKER)  # 매번!

# 이후: 시작할 때 1회만 받고, 5분마다 당일분만 갱신
df_cached = data_manager.fetch_large_data(TICKER)  # 1회
# 루프 안에서:
df_cached = data_manager.refresh_data(df_cached, TICKER)  # 당일만
```

**고친 것 3: AI 학습 타겟 변경**
```python
# 이전: 10분 뒤에 올라?
df['target'] = (df['종가'].shift(-2) > df['종가']).astype(int)

# 이후: 50분 이내에 1.2% 수익에 도달해?
for i in range(len(df) - 10):
    future_prices = df['고가'].iloc[i+1:i+11]
    max_profit = (future_prices / df['종가'].iloc[i] - 1).max()
    if max_profit >= 0.012:
        target.iloc[i] = 1
```

**고친 것 4: 데이터 누수 제거**
```python
# 이전: 전체 데이터로 학습 → 같은 데이터로 백테스트 (치팅!)
ai_brain = model.load_model("trading_brain.json")  # 전체 데이터로 학습된 모델
# 그 모델로 전체 기간 백테스트...

# 이후: 앞쪽 75%로 학습, 뒤쪽 25%로만 테스트 (정직한 시험)
split_idx = int(len(df) * 0.75)
train_data = df.iloc[:split_idx]    # 학습용 (과거)
test_data = df.iloc[split_idx:]     # 시험용 (미래)
ai_brain.fit(train_data[features], train_data['target'])
# 시험용 데이터로만 백테스트!
```

**고친 것 5: K값 현실화 + 확신도 완화**
```
K값: 0.5 → 0.3 → 0.2 (목표가를 현실적으로)
확신도: 75% → 65% → 60% (진입 기회 증가)
```

**고친 것 6: 토큰 자동 갱신**
```python
# 이전: 토큰 갱신 없음 (24시간 후 만료되면 봇 멈춤)
# 이후: 23시간마다 자동 갱신
if (now - token_issued_time).total_seconds() > 82800:
    token = broker.get_access_token(...)
```

**고친 것 7: 트레일링 스탑 도입**
```python
# 이전: 고정 익절 (1.2% 오르면 무조건 판다)
if profit_rate >= 0.012: sell()

# 이후: 트레일링 스탑 (계속 올라가면 따라가다가, 꺾이면 판다)
if price > highest_price:
    highest_price = price  # 최고가 갱신
if profit_rate >= 0.015 and drop_from_peak >= 0.010:
    sell()  # 고점에서 1% 떨어지면 매도
```
> 불장에서 1.2%에 기계적으로 파는 대신, 10%까지 올라가면 10%를 먹을 수 있음

### 이 단계의 백테스팅 결과들

**첫 시도 (k=0.3, 확신도 75%)**
```
수익률: -0.49% | 거래 3회 | 승률 100%
문제: 3번 이겼는데 수수료 때문에 손해 (수익 < 수수료)
```

**두 번째 시도 (k=0.2, 확신도 60%, 트레일링 스탑)**
```
수익률: -5.66% | 거래 12회 | 승률 67%
문제: 거래를 더 많이 했지만 수수료가 더 먹어치움
비교: Buy & Hold는 같은 기간 +32.72%
```

### 핵심 깨달음

> **AI 정확도 57%로는 수수료 0.93%를 이길 수 없다.**
>
> 계산:
> - 57% 확률로 이기고, 평균 1.5% 수익
> - 43% 확률로 지고, 평균 1.5% 손실
> - 기대 수익 = 0.57 × 1.5% - 0.43 × 1.5% = +0.21%/거래
> - 수수료 차감 = 0.21% - 0.93% = **-0.72%/거래**
> - 거래할수록 돈을 잃는 구조!

---

## 3단계: 전략 비교 실험

### 왜 전략을 바꿨나

5분봉 AI 단타가 구조적으로 수수료를 이길 수 없다는 걸 깨달은 후,
**일봉(하루 1개 데이터) 기반으로 전환**하고 여러 전략을 비교 실험함.

### 비교한 4가지 전략

#### 전략 1: MA 골든/데드크로스
```
매수: 5일 평균선이 20일 평균선을 위로 뚫고 올라가면 (골든크로스)
매도: 5일 평균선이 20일 평균선을 아래로 뚫고 내려가면 (데드크로스)
```
> 비유: "최근 성적이 장기 평균을 넘어서는 순간 투자, 다시 떨어지면 철수"

#### 전략 2: RSI 스윙
```
매수: RSI가 35 이하 (과매도, 너무 떨어진 상태) + 상승추세
매도: RSI가 70 이상 (과매수, 너무 오른 상태) 또는 손절 -3%
```
> 비유: "세일할 때 사서, 너무 비싸지면 판다"

#### 전략 3: 트렌드 추종
```
매수: 현재 가격이 20일 평균선 위 + RSI 50 이상
매도: 현재 가격이 20일 평균선 아래로 떨어지면
```
> 비유: "올라가는 에스컬레이터를 타고, 내려가기 시작하면 내린다"

#### 전략 4: AI(XGBoost) 일봉
```
학습: "향후 5일 이내에 3% 수익 도달 여부"를 예측하도록 훈련
매수: AI가 60% 이상 확률로 올라간다고 예측
매도: +3% 익절 / -2% 손절 / 확신도 40% 미만
```

### 실험 결과 (2025-11-24 ~ 2026-02-10, 54일)

```
============================================================
🏆 수익률 순위
============================================================
  1위: Buy & Hold      +59.44% (0회 거래) ← 최고
  2위: 트렌드 추종      +21.13% (3회 거래)
  3위: MA 크로스오버     +20.15% (2회 거래)
  4위: AI 일봉          +8.16% (13회 거래)
  5위: RSI 스윙         +0.00% (0회 거래)
============================================================
```

### 결과 분석

**왜 Buy & Hold가 1위?**
> 테스트 기간이 강한 상승장이었음 (12,805원 → 16,995원, +59%).
> 불장에서는 아무것도 안 하고 들고 있는 게 최고.
> 어떤 전략이든 중간에 팔았다 다시 사면 수수료 + 타이밍 손실 발생.

**왜 트렌드 추종이 2위?**
> 거래 3회만 했음. 한 번 사면 오래 들고 있다가 추세가 꺾일 때만 팔았음.
> 수수료 영향 최소화 + 상승 추세를 대부분 탔음.

**왜 AI가 4위?**
> 13회 거래. 수수료만 13 × 0.93% = 12.09% 날림.
> AI가 아무리 잘 맞춰도 잦은 매매가 수익을 갉아먹음.

**핵심 교훈:**
> 적게 거래할수록 좋다. 수수료는 확실한 손실이지만, 예측은 불확실하다.

---

## 4단계: 최종 버전 (트렌드 추종)

### 전략 선택 이유

실험에서 **트렌드 추종**이 능동적 전략 중 가장 좋았음.
Buy & Hold가 1위였지만, 하락장에서는 -30~50% 손실을 그대로 맞기 때문에
"상승할 때 타고, 하락할 때 빠지는" 트렌드 추종을 채택.

### 최종 전략 (현재 main.py)
```
매수: 현재 가격 > 20일 이동평균(MA20) + RSI > 50
매도: 현재 가격 < 20일 이동평균(MA20)
체크: 5분마다 현재가 확인
데이터: 일봉 (하루 1회만 갱신)
```

### v1.0 → 최종 비교표

| 항목 | v1.0 (최초) | 최종 (현재) |
|------|------------|------------|
| **전략** | 변동성돌파 + AI 5분봉 | 트렌드 추종 (MA20) |
| **데이터** | 5분봉 17,000개 (매분 다운로드) | 일봉 60개 (하루 1회) |
| **매수 조건** | 목표가 돌파 AND AI 75% | 가격 > MA20 AND RSI > 50 |
| **매도 조건** | +1.2% 익절 / -1% 손절 | MA20 아래로 이탈 |
| **매수 수량** | 1주 고정 | 잔고의 95% |
| **체크 주기** | 60초 | 300초 (5분) |
| **거래 빈도** | 하루 여러 번 | 월 2~3회 |
| **AI 사용** | XGBoost 12개 지표 | 사용 안 함 |
| **토큰 갱신** | 없음 (24시간 후 멈춤) | 23시간마다 자동 |
| **네트워크** | 매우 무거움 | 거의 없음 |
| **코드 복잡도** | 5개 파일 전부 사용 | main.py + broker.py만 |

---

## 현재 코드 설명 (기능 단위)

### main.py - 봇의 두뇌

#### `log_trade()` - 매매 일지 기록
```python
def log_trade(side, price, quantity, profit=0, reason=""):
```
**하는 일:** 주식을 사거나 팔 때마다 `trade_log.csv` 파일에 기록을 남김.
- `side`: "매수" 또는 "매도"
- `price`: 얼마에 사거나 팔았는지
- `quantity`: 몇 주를 사거나 팔았는지
- `profit`: 수익률 (매도할 때만)
- `reason`: 왜 샀는지/팔았는지

**비유:** 용돈기입장. 언제, 무엇을, 얼마에, 왜 사고팔았는지 적는 것.

#### `get_daily_indicators()` - 일봉 지표 계산
```python
def get_daily_indicators():
```
**하는 일:** 인터넷(yfinance)에서 최근 60일간의 하루하루 가격을 받아와서 MA5, MA20, RSI를 계산.
- `MA5`: 최근 5일 평균 가격
- `MA20`: 최근 20일 평균 가격
- `RSI`: 주가의 "체력 게이지" (0~100)

**비유:** 60일치 시험 성적을 받아와서 최근 평균과 장기 평균을 계산하는 것.

#### `run_bot()` - 메인 실행 함수
```python
def run_bot():
```
**하는 일 순서:**
1. 증권사에서 입장권(토큰) 받기
2. 현재 내 계좌에 주식이 있는지 확인
3. 일봉 데이터 받아서 지표 계산
4. 무한 반복:
   - 장 운영 시간(09:00~15:30)인지 확인
   - 하루 1번 일봉 데이터 갱신
   - 현재 가격 확인
   - "지금 상승추세야?" 판단 (현재가 > MA20?)
   - 주식 없으면 → 상승추세 + RSI OK → 매수!
   - 주식 있으면 → 하락추세 → 매도!
   - 5분 쉬고 반복

---

### broker.py - 증권사와 대화하는 직원

#### `get_access_token()` - 입장권 받기
```python
def get_access_token(app_key, app_secret, url_base):
```
**하는 일:** 한국투자증권에 "저 들어가도 돼요?" 하고 입장권(토큰)을 받아옴.
- `app_key`, `app_secret`: 본인 확인용 열쇠 (비밀번호 같은 것)
- 이 토큰이 있어야 주식을 사고팔 수 있음
- 24시간 후에 만료됨

**비유:** 놀이공원 입장 팔찌. 하루 지나면 새로 받아야 함.

#### `get_current_price()` - 지금 가격이 얼마야?
```python
def get_current_price(token, app_key, app_secret, url_base, stock_code):
```
**하는 일:** 한국투자증권 실전 서버에서 KODEX 150 레버리지의 현재 가격을 가져옴.
- 실전 서버(URL_REAL)를 사용하는 이유: 시세는 실전이 가장 정확하니까!

**비유:** 마트에 전화해서 "사과 지금 얼마예요?" 물어보는 것.

#### `get_balance()` - 내 통장에 얼마 있어?
```python
def get_balance(token, app_key, app_secret, url_base, acc_no):
```
**하는 일:** 계좌에서 주식을 살 수 있는 현금이 얼마인지 확인.

**비유:** ATM에서 잔액 조회하는 것.

#### `get_stock_balance()` - 내가 산 주식의 평균 가격
```python
def get_stock_balance(token, app_key, app_secret, url_base, acc_no, stock_code):
```
**하는 일:** 내가 보유한 특정 종목의 매수 평균가를 확인.
- 수익률 계산에 필요: (현재가 - 매수가) / 매수가

**비유:** "내가 이 주식을 평균 얼마에 샀더라?" 확인.

#### `get_holding_quantity()` - 내가 몇 주 갖고 있어?
```python
def get_holding_quantity(token, app_key, app_secret, url_base, acc_no, stock_code):
```
**하는 일:** 내가 특정 종목을 몇 주 보유하고 있는지 확인. 매도할 때 정확한 수량이 필요.

**비유:** "내 사물함에 사과가 몇 개 있지?" 확인.

#### `post_order()` - 주식 사주세요!
```python
def post_order(token, app_key, app_secret, url_base, acc_no, stock_code, quantity):
```
**하는 일:** 시장가로 매수 주문을 넣음.
- `quantity`: 몇 주 살 건지
- 시장가 주문이므로 가장 빠르게 체결됨

**비유:** 마트에서 "사과 55개 주세요, 지금 가격으로요!" 하는 것.

#### `post_sell_order()` - 주식 팔아주세요!
```python
def post_sell_order(token, app_key, app_secret, url_base, acc_no, stock_code, quantity):
```
**하는 일:** 시장가로 매도 주문을 넣음. 매수와 거의 같지만 `tr_id`가 다름.
- 매수: `VTTC0802U`
- 매도: `VTTC0801U`

---

### backtester.py - 타임머신 시뮬레이터

#### `prepare_daily_data()` - 1년치 일봉 데이터 준비
```python
def prepare_daily_data(ticker):
```
**하는 일:** yfinance에서 1년치 일봉 데이터를 받아와서 모든 기술적 지표를 계산.
MA5, MA20, RSI, 볼린저밴드, MACD, 거래량 비율 등.

**비유:** 1년치 시험 성적표를 받아와서 각종 통계를 계산하는 것.

#### `strategy_ma_crossover()` - 전략1: MA 크로스
```python
def strategy_ma_crossover(df, total_fee):
```
**하는 일:** 골든크로스(MA5가 MA20 위로) 때 사고, 데드크로스(MA5가 MA20 아래로) 때 팔아보는 시뮬레이션.

#### `strategy_rsi_swing()` - 전략2: RSI 스윙
```python
def strategy_rsi_swing(df, total_fee):
```
**하는 일:** RSI가 35 이하(과매도)일 때 사고, 70 이상(과매수)일 때 팔아보는 시뮬레이션.

#### `strategy_trend_follow()` - 전략3: 트렌드 추종 (채택된 전략!)
```python
def strategy_trend_follow(df, total_fee):
```
**하는 일:** 가격이 MA20 위에 있으면 사서 보유하고, MA20 아래로 떨어지면 파는 시뮬레이션.
이 전략이 능동적 전략 중 가장 좋은 성적을 내서 현재 main.py에 채택됨.

#### `strategy_ai_daily()` - 전략4: AI 일봉
```python
def strategy_ai_daily(df, total_fee):
```
**하는 일:** XGBoost AI를 일봉 데이터로 학습시켜서, AI 예측에 따라 사고팔아보는 시뮬레이션.
- 앞쪽 75% 데이터로 학습 → 뒤쪽 25% 데이터로 테스트 (데이터 누수 방지)

#### `run_backtest()` - 전체 실행 및 비교
```python
def run_backtest():
```
**하는 일:** 위 4가지 전략 + Buy&Hold를 모두 돌려보고 수익률 순위를 매김.

---

### data_manager.py - 데이터 수집가 (현재 main.py에서는 미사용)

#### `fetch_large_data()` - 60일치 5분봉 데이터 수집
```python
def fetch_large_data(ticker):
```
**하는 일:** 종목의 60일치 5분봉 데이터 + 코스닥 지수 데이터를 받아옴.
v1.0~v2.0에서 사용했으나, 현재 main.py는 일봉 전략으로 바뀌어서 직접 사용 안 함.

#### `fetch_today_data()` - 당일 데이터만 받기
```python
def fetch_today_data(ticker):
```
**하는 일:** 오늘 하루치 5분봉 데이터만 가볍게 받아옴.

#### `refresh_data()` - 데이터 갱신
```python
def refresh_data(df_base, ticker):
```
**하는 일:** 기존에 받아둔 60일 데이터에서 오늘 부분만 새 데이터로 교체.

#### `add_indicators()` - 기술적 지표 계산
```python
def add_indicators(df):
```
**하는 일:** 볼린저밴드, MACD, RSI, MA 등 12개 지표를 계산하고, AI 학습용 정답지(target)도 만듦.

#### `get_target_price()` - 래리 윌리엄스 목표가 계산
```python
def get_target_price(ticker, k=0.2):
```
**하는 일:** `오늘 시가 + (전일 변동폭 × K)` 공식으로 돌파 목표가를 계산.
v1.0에서 사용했으나, 현재 main.py에서는 사용하지 않음.

---

### model.py - AI 선생님 (현재 main.py에서는 미사용)

#### `train_model()` - AI 학습시키기
```python
def train_model(df, features, num_features):
```
**하는 일:** XGBoost라는 AI에게 "이런 지표 상황에서 가격이 올랐어/안 올랐어"를 가르침.
- 데이터의 80%로 공부시키고, 20%로 시험을 봐서 정확도를 확인.

#### `save_model()` / `load_model()` - AI 기억 저장/불러오기
```python
def save_model(model, filename):
def load_model(filename):
```
**하는 일:** 학습된 AI를 파일로 저장하거나 불러옴. 매번 새로 학습하면 느리니까.

---

## 배운 교훈 정리

### 1. 단순한 전략이 복잡한 전략을 이긴다
> MA20 하나로 판단하는 트렌드 추종(+21%)이
> AI + 12개 지표 + 변동성 돌파의 하이브리드(-5.66%)를 압도했다.

### 2. 수수료는 확실한 적이다
> 모의투자 수수료 왕복 0.93%는 거래할 때마다 확실히 빠져나감.
> 12번 거래하면 수수료만 11.16% 손실.
> 불확실한 수익보다 확실한 비용을 줄이는 게 중요.

### 3. 적게 거래할수록 좋다
> 거래 0회(Buy&Hold): +59% → 거래 3회(트렌드): +21% → 거래 13회(AI): +8%
> 거래 횟수와 수익률이 반비례!

### 4. 데이터 누수를 조심해라
> 학습에 쓴 데이터로 시험을 보면 당연히 성적이 좋지만, 실전에서는 통하지 않음.
> 반드시 시계열 분할(과거 학습, 미래 테스트)을 해야 함.

### 5. 백테스팅은 과거일 뿐이다
> 과거에 잘 됐다고 미래에도 잘 되는 건 아님.
> 특히 "불장에서 Buy&Hold가 최고"라는 결과는
> "다음에도 불장이면" 이라는 전제가 필요함.
> 트렌드 추종의 가치는 하락장에서 손실을 제한하는 데 있음.

### 6. 레버리지 ETF는 변동성이 크다
> 일반 ETF보다 2배 움직이므로, 손절/익절 기준도 넉넉하게 잡아야 함.
> 너무 빡빡한 기준은 정상적인 변동에도 매매를 유발.

---

## 앞으로의 과제

- [ ] 실전 투자로 전환할 때 `URL_MOCK` → `URL_REAL`, `tr_id` 변경 필요
- [ ] 실전 수수료는 모의투자의 약 1/10 수준이므로 백테스트 재실행 필요
- [ ] 하락장 구간을 포함한 더 긴 기간(2~3년)으로 백테스트 필요
- [ ] 트렌드 추종이 하락장에서 실제로 손실을 제한하는지 검증 필요
